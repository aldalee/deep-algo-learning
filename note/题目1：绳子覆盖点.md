## 绳子覆盖点

---

### 题目描述

给定一个**有序**数组 $arr$，代表坐落在 $x$ 轴上的点。给定一个正数 $k$，代表绳子的长度，返回绳子最多压中几个点？即使绳子边缘处盖住点也算盖住。

### 题目分析

如图，假设绳子的长度是 $4$，则覆盖的点数最多是 $4$ 个，图中阴影部分。可以看到，绳子的开头（或结尾）没有必要放在不存在的点数上，这其实是一种贪心策略。

![001-绳子覆盖点.drawio.svg](../img/001-绳子覆盖点.drawio.svg)

### 解法一：二分法+贪心

假定绳子的结尾部分顶在坐标  $x$ 处，绳子的长度是 $k$ ，那么左侧的坐标是 $x-k$，所以当前绳子覆盖的坐标区间是 $[x-k, x]$，则只需要计算有多少点在这个区间内[1]，便得到当前的一个答案数，遍历完一遍后，一定得到最终的问题答案。

而计算[1]，只需要用二分法计算 $x-k$ 这个数字在原数组中的下标索引，然后

$$
Index(x) - Index({x-k}) + 1
$$

就是当前这一步[1]的答案。

- 时间复杂度：$O(n\log n)$
  
  ```go
  func maxCordCover(points []int, k int) int {
    var res int
    for i, point := range points {
        idx, _ := slices.BinarySearch(points[:i+1], point-k)
        res = max(res, i-idx+1)
    }
    return res
  }
  ```
  
  ### 解法二：双指针+贪心
  
  假定绳子的开始部分（**左指针**）顶在坐标 $x$ 处，然后**右指针**一直向右滑动，直到绳子的长度 $k$ 不能罩住窗口的长度，记下此时的答案。
  然后窗口右移一位，继续判断绳子能否罩住，遍历完一遍后，最大的答案值即为所求。
- 时间复杂度：$O(n)$
  
  ```go
  func maxCordCover(points []int, k int) int {
    var l, r, res int
    for l < len(points) {
        for r < len(points) && points[r]-points[l] <= k {
            r++
        }
        res = max(res, r-l)
        l++
    }
    return res
  }
  ```